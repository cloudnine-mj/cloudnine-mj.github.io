# 운영 체제 기본

## Process & Thread

### Process

* OS(운영체제)의 자원을 할당 받는 최소 단위

* 프로그램 파일을 실행함으로써 프로그램 데이터들이 메모리에 올라와 CPU를 할당받고 명령을 수행하는 상태

* OS는 프로세스마다 각각 독립된 메모리(RAM)의 영역을 Code, Data, Stack, Heap 형식으로 할당

	| 영역  | 설명                                                         |
	| ----- | ------------------------------------------------------------ |
	| Code  | - 실행할 프로그램의 코드가 저장되는 영역으로, text영역이라고도 함. <br />- 프로그램이 시작하고 끝날 때까지 메모리에 계속 남아 있음. <br />- 컴파일된 기계어가 들어감. <br />- CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리함. |
	| Data  | - 프로그램의 전역(global) 변수와 정적(static)변수, 문자열 상수가 저장되는 영역. <br />- 데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸함. <br />- BSS와 GVAR 영역을 통츨어 data 영역이라고 함. |
	| Stack | - 프로그램이 자동으로 사용하는 임시 메모리 영역. 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역. <br />- 스택 영역의 크기는 컴파일 시에 결정됨. 스택 영역은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸함. <br />- 스택 영역에 저장되는 함수의 호출 정보를 스택 프레임(stack frame)이라고 함. <br />- 스택 영역은 후입 선출(LIFO, Last-In First-Out) 의 방식으로, 가장 나중에 들어온 데이터가 가장 먼저 인출됨.  -> 스택 영역이 메모리의 높은 주소에서 낮은 주소의 방향으로 할당 되기 때문 스택 영역에서 푸시(push) 로 데이터를 저장하고, 팝(pop) 으로 데이터를 인출 |
	| Heap  | - 사용자가 직접 관리할 수 있고, 관리해야만 하는 영역. <br />- 힙 영역은 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됨. <br />- 힙 영역은 선입선출(FIFO, First-In First-Out)의 방식으로, 가장 먼저 들어온 데이터가 가장 먼저 인출. -> 힙 영역이 메모리의 낮은 주소에서 높은 주소의 방향으로 할당되기 떄문 런타임 시에 크기가 결정됨. |
	
* 기본적으로 다른 프로세스의 변수나 자료에 접근할 수 없음.  (IPC나 공유 메모리 등의 통신 기법들을 사용해서 프로세스 간 통신을 해야 함.)
	

<br>

###  Thread

* 프로세스가 운영체제로부터 할당 받은 자원을 이용하는 실행단위 또는 흐름의 단위 (하나의 프로세스는 하나 이상의 스레드를 갖음.)
* 프로세스 내에서 각 필요한 Stack만 할당받고 Code, Data, Heap 영역은 공유 후 Thread에 할당함.
* 스레드 간 메모리 Stack 영역에 접근 할 수 없음 -> 독립적인 실행 흐름을 가질 수 있게 되며, 독립적인 함수 호출이 가능해짐.

:point_right: 실질적으로 Process에서 OS 자원을 소모하는 역할 (CPU 최소 실행 단위)
:point_right: Thread의 선점이 일어날 때 CPU Context Switching 이 발생함.

<br>


### Process와 Thread 비교

| Process                                                      | Thread                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| - 여러 개의 자식 프로세스 중 하나가 문제가 생겨도 다른 프로세스에는 영향을 미치지 않음.<br />- 프로세스 전환 시 비용 발생 <br />- 통신 오버헤드가 큼 <br />- 프로세스 생성 시 독립적으로 메모리가 할당 -> 리소스 비용 큼 | - 여러 개의 Thread 중 단 한 개라도 문제가 발생하면 전체 프로세스에 영향을 미침.<br />- 하나의 Thread에서 오류가 발생하더라도 프로세스 자체가 종료될 수 있음.<br />- 프로세스의 메모리 영역을 공유하기 때문에 Context Switching이 적음. (리소스를 효율적으로 사용할 수 있음.) <br />- 통신 오버헤드가 적음.<br />- Thread 간 공유 메모리 영역의 동시 접근으로 인해 동기화 문제가 발생함.<br /> |

